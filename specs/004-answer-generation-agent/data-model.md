# Data Model: RAG Answer Generation Agent

**Feature**: 004-answer-generation-agent
**Created**: 2025-12-25
**Purpose**: Define core entities, relationships, and validation rules

## Entity Definitions

### 1. QueryRequest

**Purpose**: User input to the RAG system

**Attributes**:
- `query` (string, required): User's question or request
  - Validation: 1-500 characters, non-empty after trimming
  - Example: "How does ROS 2 work?"
- `selected_text` (string | null, optional): User-highlighted text from book
  - Validation: If provided, 10-5000 characters
  - Example: "Nodes in ROS 2 communicate via topics"
- `top_k` (integer, optional): Number of chunks to retrieve
  - Validation: 1-20, default=5
  - Example: 10
- `session_id` (UUID, optional): Session identifier for tracking
  - Validation: UUID v4 format
  - Example: "550e8400-e29b-41d4-a716-446655440000"

**Relationships**:
- Transformed into PlannedWorkflow by Planner Agent
- Logged to PostgreSQL queries table

**State Transitions**: None (immutable input)

**Validation Rules**:
```python
class QueryRequest(BaseModel):
    query: str = Field(..., min_length=1, max_length=500)
    selected_text: Optional[str] = Field(None, min_length=10, max_length=5000)
    top_k: int = Field(5, ge=1, le=20)
    session_id: Optional[UUID] = None

    @validator('query')
    def query_not_empty(cls, v):
        if not v.strip():
            raise ValueError('Query cannot be empty')
        return v.strip()
```

---

### 2. PlannedWorkflow

**Purpose**: Routing decision from Planner Agent

**Attributes**:
- `mode` (enum, required): Workflow type
  - Values: `standard_rag` | `selected_text_only`
  - Example: `standard_rag`
- `query` (string, required): Original user query
  - Same as QueryRequest.query
- `top_k` (integer, required): Number of chunks to retrieve
  - Same as QueryRequest.top_k
- `selected_text` (string | null, required): Selected text if mode=selected_text_only
  - Required if mode=selected_text_only, null otherwise

**Relationships**:
- Created by Planner Agent from QueryRequest
- Consumed by Retriever Agent

**State Transitions**:
```
QueryRequest
  ↓ (Planner detects selected_text)
PlannedWorkflow(mode='selected_text_only')

QueryRequest
  ↓ (Planner detects no selected_text)
PlannedWorkflow(mode='standard_rag')
```

**Validation Rules**:
```python
class WorkflowMode(str, Enum):
    STANDARD_RAG = "standard_rag"
    SELECTED_TEXT_ONLY = "selected_text_only"

class PlannedWorkflow(BaseModel):
    mode: WorkflowMode
    query: str
    top_k: int
    selected_text: Optional[str]

    @validator('selected_text')
    def validate_selected_text_mode(cls, v, values):
        if values.get('mode') == WorkflowMode.SELECTED_TEXT_ONLY and v is None:
            raise ValueError('selected_text required for selected_text_only mode')
        if values.get('mode') == WorkflowMode.STANDARD_RAG and v is not None:
            raise ValueError('selected_text must be null for standard_rag mode')
        return v
```

---

### 3. QueryEmbedding

**Purpose**: Vector representation of user query (intermediate, not stored)

**Attributes**:
- `vector` (list[float], required): 1024-dimensional embedding
  - Validation: Length == 1024, all floats in range [-1.0, 1.0]
  - Example: [0.123, -0.456, ...]
- `model` (string, required): Embedding model used
  - Value: "embed-multilingual-v3.0"
- `input_type` (string, required): Cohere input type
  - Value: "search_query"

**Relationships**:
- Generated by Retriever Agent using Cohere API
- Used for Qdrant similarity search (not stored)

**State Transitions**: None (ephemeral, discarded after search)

**Validation Rules**:
```python
class QueryEmbedding(BaseModel):
    vector: List[float] = Field(..., min_items=1024, max_items=1024)
    model: Literal["embed-multilingual-v3.0"]
    input_type: Literal["search_query"]

    @validator('vector')
    def validate_vector_range(cls, v):
        if not all(-1.0 <= val <= 1.0 for val in v):
            raise ValueError('All vector values must be in range [-1.0, 1.0]')
        return v
```

---

### 4. RetrievedChunk

**Purpose**: Single text chunk returned by Retriever Agent

**Attributes**:
- `chunk_id` (string, required): Unique identifier
  - Validation: Non-empty string
  - Example: "abc123" (Qdrant point ID) or "selected_text" (special case)
- `text` (string, required): Chunk content
  - Validation: Non-empty, max 10,000 characters
  - Example: "ROS 2 is the nervous system of modern robots..."
- `chapter` (string | null, optional): Chapter name from metadata
  - Example: "Chapter 2: ROS 2 Fundamentals"
- `section` (string | null, optional): Section heading from metadata
  - Example: "Learning Objectives"
- `source_url` (string | null, optional): Textbook page URL
  - Example: "https://shumailaaijaz.github.io/physical-ai-textbook/docs/02-ros2-fundamentals"
- `similarity_score` (float, required): Cosine similarity to query
  - Validation: 0.0-1.0 (or 1.0 for selected_text mode)
  - Example: 0.672

**Relationships**:
- Returned by Retriever Agent (list of 0-20 chunks)
- Consumed by Answer Generator Agent
- Metadata (chapter, section, source_url) extracted from Qdrant payload

**Special Cases**:
- Selected-text mode: chunk_id="selected_text", metadata fields null, score=1.0

**Validation Rules**:
```python
class RetrievedChunk(BaseModel):
    chunk_id: str = Field(..., min_length=1)
    text: str = Field(..., min_length=1, max_length=10000)
    chapter: Optional[str] = None
    section: Optional[str] = None
    source_url: Optional[HttpUrl] = None
    similarity_score: float = Field(..., ge=0.0, le=1.0)
```

---

### 5. Citation

**Purpose**: Source attribution for answer claims

**Attributes**:
- `chapter` (string | null, optional): Chapter name
  - Example: "Chapter 2: ROS 2 Fundamentals"
- `section` (string | null, optional): Section heading
  - Example: "Learning Objectives"
- `source_url` (string | null, optional): Textbook page URL
  - Example: "https://shumailaaijaz.github.io/physical-ai-textbook/docs/02-ros2-fundamentals"
- `referenced_text` (string, optional): Specific claim from answer
  - Example: "ROS 2 is the nervous system of modern robots"

**Relationships**:
- Generated by Answer Generator Agent
- Derived from RetrievedChunk metadata
- Included in GroundedAnswer

**Validation Rules**:
```python
class Citation(BaseModel):
    chapter: Optional[str] = None
    section: Optional[str] = None
    source_url: Optional[HttpUrl] = None
    referenced_text: Optional[str] = Field(None, max_length=500)

    @validator('*', pre=True, always=True)
    def at_least_one_field(cls, v, values):
        # At least one of chapter, section, or source_url must be present
        if not any([values.get('chapter'), values.get('section'), values.get('source_url')]):
            raise ValueError('Citation must have at least one of: chapter, section, source_url')
        return v
```

---

### 6. GroundedAnswer

**Purpose**: Successful answer with citations

**Attributes**:
- `text` (string, required): Synthesized answer
  - Validation: Non-empty, max 2000 characters
  - Example: "ROS 2 is the nervous system of modern robots, connecting sensors, actuators, and AI into a unified organism..."
- `citations` (list[Citation], required): Source attributions
  - Validation: At least 1 citation required for non-refusal answers
  - Example: [Citation(...), Citation(...)]
- `mode` (WorkflowMode, required): How answer was generated
  - Values: `standard_rag` | `selected_text_only`

**Relationships**:
- Created by Answer Generator Agent
- Returned to user in QueryResponse

**State Transitions**: None (immutable output)

**Validation Rules**:
```python
class GroundedAnswer(BaseModel):
    text: str = Field(..., min_length=1, max_length=2000)
    citations: List[Citation] = Field(..., min_items=1)
    mode: WorkflowMode

    @validator('citations')
    def at_least_one_citation(cls, v):
        if len(v) == 0:
            raise ValueError('Grounded answer must have at least one citation')
        return v
```

---

### 7. RefusalMessage

**Purpose**: Structured refusal when grounding insufficient

**Attributes**:
- `reason` (string, required): Standardized refusal message
  - Values (from spec):
    - "The provided book content does not contain sufficient information to answer this question" (FR-004, FR-012)
    - "The selected text does not contain this information" (FR-006)
  - Validation: Must be one of the standardized messages
- `refusal_type` (enum, required): Classification of refusal
  - Values: `empty_retrieval` | `low_relevance` | `insufficient_grounding` | `selected_text_missing`

**Relationships**:
- Created by Answer Generator Agent when conditions met
- Returned to user in QueryResponse

**Validation Rules**:
```python
class RefusalType(str, Enum):
    EMPTY_RETRIEVAL = "empty_retrieval"  # No chunks returned (FR-004, FR-012)
    LOW_RELEVANCE = "low_relevance"  # Top-1 score < 0.4
    INSUFFICIENT_GROUNDING = "insufficient_grounding"  # Requires reasoning not in text (FR-015)
    SELECTED_TEXT_MISSING = "selected_text_missing"  # Answer not in selected text (FR-006)

REFUSAL_MESSAGES = {
    RefusalType.EMPTY_RETRIEVAL: "The provided book content does not contain sufficient information to answer this question",
    RefusalType.LOW_RELEVANCE: "The provided book content does not contain sufficient information to answer this question",
    RefusalType.INSUFFICIENT_GROUNDING: "The provided book content does not contain sufficient information to answer this question",
    RefusalType.SELECTED_TEXT_MISSING: "The selected text does not contain this information"
}

class RefusalMessage(BaseModel):
    reason: str
    refusal_type: RefusalType

    @validator('reason')
    def validate_reason(cls, v, values):
        refusal_type = values.get('refusal_type')
        expected_message = REFUSAL_MESSAGES.get(refusal_type)
        if v != expected_message:
            raise ValueError(f'Refusal message must be: "{expected_message}"')
        return v
```

---

### 8. QueryResponse

**Purpose**: API response envelope

**Attributes**:
- `status` (enum, required): Response status
  - Values: `success` | `refused` | `error`
- `answer` (GroundedAnswer | null, conditional): Present if status=success
- `refusal` (RefusalMessage | null, conditional): Present if status=refused
- `error` (ErrorDetail | null, conditional): Present if status=error
- `metadata` (ResponseMetadata, required): Execution metadata

**Relationships**:
- Top-level response returned by FastAPI `/api/query` endpoint
- Contains exactly one of: answer, refusal, error

**State Transitions**: None (final response)

**Validation Rules**:
```python
class ResponseStatus(str, Enum):
    SUCCESS = "success"
    REFUSED = "refused"
    ERROR = "error"

class ResponseMetadata(BaseModel):
    chunks_retrieved: int
    processing_time_ms: int
    session_id: Optional[UUID]
    request_id: UUID

class QueryResponse(BaseModel):
    status: ResponseStatus
    answer: Optional[GroundedAnswer] = None
    refusal: Optional[RefusalMessage] = None
    error: Optional[ErrorDetail] = None
    metadata: ResponseMetadata

    @validator('*', pre=True, always=True)
    def validate_exclusive_fields(cls, v, values):
        # Exactly one of answer, refusal, error must be present
        status = values.get('status')
        answer = values.get('answer')
        refusal = values.get('refusal')
        error = values.get('error')

        if status == ResponseStatus.SUCCESS and answer is None:
            raise ValueError('answer required when status=success')
        if status == ResponseStatus.REFUSED and refusal is None:
            raise ValueError('refusal required when status=refused')
        if status == ResponseStatus.ERROR and error is None:
            raise ValueError('error required when status=error')

        # Ensure exclusivity
        non_null_count = sum([answer is not None, refusal is not None, error is not None])
        if non_null_count != 1:
            raise ValueError('Exactly one of answer, refusal, error must be present')

        return v
```

---

### 9. ErrorDetail

**Purpose**: Structured error information

**Attributes**:
- `code` (enum, required): Machine-readable error code
  - Values: `QDRANT_TIMEOUT` | `COHERE_FAILURE` | `OPENROUTER_TIMEOUT` | `VALIDATION_FAILED` | `RATE_LIMIT_EXCEEDED`
- `message` (string, required): Human-readable error message
  - Example: "The search service is temporarily unavailable. Please try again."
- `details` (string, optional): Technical details for debugging
  - Example: "Qdrant connection timeout after 5s"
- `retry_after` (integer | null, optional): Seconds to wait before retry (for rate limiting)

**Relationships**:
- Included in QueryResponse when status=error

**Validation Rules**:
```python
class ErrorCode(str, Enum):
    QDRANT_TIMEOUT = "QDRANT_TIMEOUT"
    COHERE_FAILURE = "COHERE_FAILURE"
    OPENROUTER_TIMEOUT = "OPENROUTER_TIMEOUT"
    VALIDATION_FAILED = "VALIDATION_FAILED"
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"

class ErrorDetail(BaseModel):
    code: ErrorCode
    message: str = Field(..., min_length=1, max_length=200)
    details: Optional[str] = Field(None, max_length=500)
    retry_after: Optional[int] = Field(None, ge=0)
```

---

## Entity Relationships

```
QueryRequest
  ↓
PlannedWorkflow (created by Planner)
  ↓
QueryEmbedding (generated by Retriever if mode=standard_rag)
  ↓
List[RetrievedChunk] (returned by Retriever)
  ↓
┌─────────────────────────────────────────┐
│       Answer Generator Agent            │
├─────────────────────────────────────────┤
│  If sufficient grounding:               │
│    → GroundedAnswer (with Citations)    │
│  Else:                                  │
│    → RefusalMessage                     │
│  On error:                              │
│    → ErrorDetail                        │
└─────────────────────────────────────────┘
  ↓
QueryResponse (envelope with exactly one of: answer, refusal, error)
```

---

## Database Schema (PostgreSQL)

**Sessions Table**:
```sql
CREATE TABLE query_sessions (
  session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMP DEFAULT NOW(),
  user_ip VARCHAR(45),
  query_count INTEGER DEFAULT 0,
  last_query_at TIMESTAMP
);
```

**Queries Table**:
```sql
CREATE TABLE queries (
  query_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES query_sessions(session_id),
  query_text TEXT NOT NULL,
  selected_text_length INTEGER,  -- Length only (privacy)
  mode VARCHAR(20) NOT NULL CHECK (mode IN ('standard_rag', 'selected_text_only')),
  status VARCHAR(20) NOT NULL CHECK (status IN ('success', 'refused', 'error')),
  refusal_reason TEXT,
  chunks_retrieved INTEGER,
  top_chunk_score FLOAT,
  processing_time_ms INTEGER,
  created_at TIMESTAMP DEFAULT NOW()
);
```

**Indexes**:
```sql
CREATE INDEX idx_sessions_ip_created ON query_sessions(user_ip, created_at);
CREATE INDEX idx_queries_status ON queries(status, created_at);
CREATE INDEX idx_queries_session ON queries(session_id);
```

---

## Key Invariants

1. **Citation Requirement**: GroundedAnswer must have ≥1 Citation
2. **Exclusive Response**: QueryResponse contains exactly one of: answer, refusal, error
3. **Mode Consistency**: selected_text must be non-null iff mode=selected_text_only
4. **Score Range**: RetrievedChunk.similarity_score always in [0.0, 1.0]
5. **Refusal Message Standardization**: RefusalMessage.reason must match predefined messages (FR-004, FR-006)
6. **No Stored Answers**: PostgreSQL does not store answer text or retrieved chunks (only metadata)

---

## Data Flow Summary

**Standard RAG Mode**:
```
QueryRequest(query="How does ROS 2 work?", selected_text=null)
  → PlannedWorkflow(mode=standard_rag)
  → QueryEmbedding(vector=[...], model="embed-multilingual-v3.0")
  → Qdrant search
  → List[RetrievedChunk] (5 chunks, scores 0.4-0.7)
  → GroundedAnswer(text="ROS 2 is...", citations=[...])
  → QueryResponse(status=success, answer=GroundedAnswer)
```

**Selected-Text Mode**:
```
QueryRequest(query="What are topics?", selected_text="Nodes in ROS 2 communicate via topics")
  → PlannedWorkflow(mode=selected_text_only)
  → List[RetrievedChunk] (1 chunk: selected text, score=1.0)
  → GroundedAnswer(text="Topics are...", citations=[]) OR RefusalMessage
  → QueryResponse(status=success/refused)
```

**Refusal Case**:
```
QueryRequest(query="How do I train GPT-4?")
  → PlannedWorkflow(mode=standard_rag)
  → QueryEmbedding → Qdrant search
  → List[RetrievedChunk] (0 chunks OR all scores <0.4)
  → RefusalMessage(reason="The provided book content...", refusal_type=empty_retrieval)
  → QueryResponse(status=refused, refusal=RefusalMessage)
```
